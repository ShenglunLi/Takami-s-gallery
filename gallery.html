<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gallery | TAKAMI's Artwork</title>
    <!-- 阻擋機器人及Pinterest -->
    <meta name="robots" content="index, follow, noai, max-image-preview:large">
    <meta name="pinterest" content="nopin" description="Sorry, you can't save from this website!" />
    <meta name="referrer" content="strict-origin-when-cross-origin">
    <link rel="icon" href="https://takami-artwork.com/img/favicon.png" type="image/png">
    <link rel="shortcut icon" href="https://takami-artwork.com/img/favicon-32.png">
    <link rel="apple-touch-icon" href="https://takami-artwork.com/img/apple-touch-icon.png">
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-25..0" />
    
    <link rel="stylesheet" href="style.css">

</head>
<body class="page-gallery">

    <div class="menu-toggle" id="menuBtn" onclick="toggleMenu()">
        <i class="fa-solid fa-bars menu-icon"></i>
    </div>
    <nav class="full-menu" id="fullMenu">
        <div class="close-menu" onclick="toggleMenu()"><i class="fa-solid fa-xmark"></i></div>
        <a href="index.html">Home</a>
        <a href="info.html">Info</a>
        <a href="gallery.html">Gallery</a>
        <a href="life.html">Life</a>
    </nav>

    <header class="page-hero page-hero-small">
        <div class="page-hero-bg"></div>
        <div class="hero-content"><h1>Gallery</h1><p>ファンアートの置き場<br>版権元とは一切関係ありません</p></div>
    </header>

    <main class="gallery-container">
        <div id="galleryContainer"></div>
    </main>

    <div id="workOverlay" class="overlay" onclick="handleOverlayClick(event)" onmousemove="resetUIInactivity()" ontouchstart="resetUIInactivity()">
        <div id="overlayCloseBtn" class="overlay-close overlay-icon" onclick="closeOverlay()">
            <!-- <span class="material-symbols-outlined">close</span> -->
             <span class="icon-svg icon-close"></span>
        </div>
        <div id="overlayBackBtn" class="overlay-back overlay-icon" onclick="backToInfo()">
            <!-- <span class="material-symbols-outlined">arrow_back</span> -->
             <span class="icon-svg icon-arrow-back"></span>

        </div>

        <div class="overlay-content">
            <div id="infoLayer" class="info-layer">
                <button class="info-nav-btn prev" id="infoPrev" onclick="changeWork(-1)"><i class="fas fa-chevron-left"></i></button>
                <div id="infoCoverBox" class="info-cover-box" onclick="tryEnterViewer()">
                    <a class="page-count-label" id="infoPageCount" onclick="tryEnterViewer()"></a>
                    <img id="infoCoverImg" src="" alt="Cover">
                </div>
                <div id="infoDetail" class="info-details">
                    <!-- <a class="page-count-label" id="infoPageCount" onclick="tryEnterViewer()"></a> -->
                    <div class="info-header-meta">
                        <div class="date-tag" id="infoDate"></div>
                        <div class="clap-section" id="clapSection">
                            <button id="clapBtn" class="clap-btn">
                                <span class="material-symbols-outlined">favorite</span>
                                <span id="clapCount">-</span>
                            </button>
                            <div id="clappedStatus" style="display: none;">
                                <span class="material-symbols-outlined">favorite</span>
                                <span id="clapCountStatus">-</span><span>拍手完了</span>
                            </div>
                        </div>
                    </div>
                    
                    <h2 id="infoTitle">作品標題</h2>
                    <p id="infoDesc">作品描述內容...</p>
                    
                </div>
                <button class="info-nav-btn next" id="infoNext" onclick="changeWork(1)"><i class="fas fa-chevron-right"></i></button>
            </div>

            <div id="viewerLayer" class="viewer-layer">
                <div class="viewer-img-container">
                    <button class="nav-btn prev-btn" id="viewPrev" onclick="changeInnerPage(-1)"><i class="fas fa-chevron-left"></i></button>
                    <img id="viewerImg" src="" alt="Work Page">
                    <button class="nav-btn next-btn" id="viewNext" onclick="changeInnerPage(1)"><i class="fas fa-chevron-right"></i></button>
                </div>
                <div class="viewer-indicator" id="viewerIndicator"></div>
            </div>
        </div>
    </div>
    <footer class="footer">
        <p>&copy; 2026 TAKAMI</p>
        <p>本サイト掲載の画像・文章の無断転載・加工・商用利用・AI学習への使用は禁止します。</p>
        <p>Unauthorized reproduction, modification, commercial use,<br class="mobile-br"> or AI training of the images and texts on this website is prohibited.<br>Fanart: Original characters and related rights belong to their respective owners.<br class="mobile-br"> Original works: All rights reserved.</p>
    </footer>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/12.7.0/firebase-app.js";
        import { getDatabase, ref, onValue, runTransaction, off } from "https://www.gstatic.com/firebasejs/12.7.0/firebase-database.js";

        const firebaseConfig = {
            apiKey: "AIzaSyDZ9fVnata2mqQb-YPceFKWEdKdQwL6nhA",
            authDomain: "takami-gallery.firebaseapp.com",
            databaseURL: "https://takami-gallery-default-rtdb.firebaseio.com",
            projectId: "takami-gallery",
            storageBucket: "takami-gallery.firebasestorage.app",
            messagingSenderId: "777768543738",
            appId: "1:777768543738:web:f8f0fcf7aa9cdc716f7043",
            measurementId: "G-JTZ69DZ4F4"
        };

        const app = initializeApp(firebaseConfig);
        const db = getDatabase(app);
        let currentClapRef = null;

        document.getElementById('clapBtn').addEventListener('click', handleClap);

        window.syncClaps = function(workId) {
            if (!workId) return;
            const clapSection = document.getElementById('clapSection');
            const clapCountDisplay = document.getElementById('clapCount');
            const clapCountStatus = document.getElementById('clapCountStatus');

            clapSection.classList.remove('ready');
            if (clapCountDisplay) clapCountDisplay.innerText = "-";
            if (clapCountStatus) clapCountStatus.innerText = "-";

            checkClapLimit(workId);
            if (currentClapRef) off(currentClapRef);

            currentClapRef = ref(db, 'claps/' + workId);
            onValue(currentClapRef, (snapshot) => {
                const count = snapshot.val() || 0;
                if (clapCountDisplay) clapCountDisplay.innerText = count;
                if (clapCountStatus) clapCountStatus.innerText = count;
                setTimeout(() => { clapSection.classList.add('ready'); }, 50);
            });
        };

        // 檢查是否還在冷卻時間內 (60分鐘 = 3,600,000 毫秒)
        function checkClapLimit(workId) {
            const history = JSON.parse(localStorage.getItem('clap_history_map') || "{}");
            const lastClapTime = history[workId]; // 取得該作品上次點擊的時間戳記
            const now = Date.now();
            const cooldown = 60 * 60 * 1000; // 60 分鐘的毫秒數

            let isLocked = false;
            if (lastClapTime) {
                // 如果現在時間距離上次點擊小於冷卻時間，則鎖定按鈕
                if (now - lastClapTime < cooldown) {
                    isLocked = true;
                }
            }

            const clapBtn = document.getElementById('clapBtn');
            const clappedStatus = document.getElementById('clappedStatus');

            if (isLocked) {
                clapBtn.style.display = 'none';
                clappedStatus.style.display = 'flex';
            } else {
                clapBtn.style.display = 'flex';
                clappedStatus.style.display = 'none';
            }
        }

    // 儲存拍手時間戳記到 LocalStorage
    function saveClapToLocal(workId) {
        const history = JSON.parse(localStorage.getItem('clap_history_map') || "{}");
        history[workId] = Date.now(); // 紀錄目前時間
        localStorage.setItem('clap_history_map', JSON.stringify(history));
        checkClapLimit(workId);
    }

    // 處理點擊拍手
    function handleClap() {
        // 這裡需要能存取到 currentIndex 與 currentFilteredWorks
        // 確保這兩個變數在您的 global scope 或可存取範圍內
        const item = currentFilteredWorks[currentIndex];
        if (!item) return;

        const clapRef = ref(db, 'claps/' + item.id);
        runTransaction(clapRef, (current) => (current || 0) + 1);
        
        saveClapToLocal(item.id);
    }

    // 監聽按鈕點擊
    document.getElementById('clapBtn').addEventListener('click', handleClap);

    // 修改原本的 syncClaps 呼叫名
    window.syncClaps = function(workId) {
        if (!workId) return;
        const clapSection = document.getElementById('clapSection');
        const clapCountDisplay = document.getElementById('clapCount');
        const clapCountStatus = document.getElementById('clapCountStatus');

        clapSection.classList.remove('ready');
        if (clapCountDisplay) clapCountDisplay.innerText = "-";
        if (clapCountStatus) clapCountStatus.innerText = "-";

        // 每次切換作品時檢查該作品是否在冷卻中
        checkClapLimit(workId);

        if (currentClapRef) off(currentClapRef);
        currentClapRef = ref(db, 'claps/' + workId);
        onValue(currentClapRef, (snapshot) => {
            const count = snapshot.val() || 0;
            if (clapCountDisplay) clapCountDisplay.innerText = count;
            if (clapCountStatus) clapCountStatus.innerText = count;
            setTimeout(() => { clapSection.classList.add('ready'); }, 50);
        });
    }
    </script>

    <script>
        let allWorks = [];
        let currentFilteredWorks = []; 
        let currentIndex = 0;       
        let currentInnerIndex = 0;  
        let isViewerActive = false; 
        let uiInactivityTimeout; 
        let touchStartX = 0, touchStartY = 0, isSwiping = false;
        let scale = 1;
        let lastScale = 1;
        let startDist = 0;
        let posX = 0, posY = 0;
        let lastPosX = 0, lastPosY = 0;
        let startTouchX = 0, startTouchY = 0;
        let isZooming = false;

        async function initGallery() {
            try {
                const response = await fetch('data/content.json');
                allWorks = await response.json();
                
                // 直接執行畫廊渲染，不再需要 renderFilters()
                renderCategorizedGallery();
                
                initTouchEvents();
            } catch (err) { 
                console.error("載入失敗:", err); 
            }
        }



        function renderCategorizedGallery() {
            const container = document.getElementById('galleryContainer');
            container.innerHTML = '';
            currentFilteredWorks = [];

            // 保留您的自定義排序順序
            const customOrder = ['カラーイラスト', '短編漫画', '落書き'];

            // 取得所有存在的分類並排序
            const existingCats = [...new Set(allWorks.map(w => w.category))];
            const sortedCats = existingCats.sort((a, b) => {
                let indexA = customOrder.indexOf(a);
                let indexB = customOrder.indexOf(b);
                
                if (indexA === -1) indexA = 999;
                if (indexB === -1) indexB = 999;
                
                return indexA - indexB;
            });

            // 依據排序後的分類進行渲染
            sortedCats.forEach(cat => {
                const works = allWorks.filter(w => w.category === cat);
                if (works.length === 0) return;

                const group = document.createElement('div');
                group.className = 'category-group';
                group.innerHTML = `<h2 class="category-title">${cat}</h2><div class="gallery-grid"></div>`;
                const grid = group.querySelector('.gallery-grid');

                works.forEach(work => {
                    const globalIdx = currentFilteredWorks.length;
                    currentFilteredWorks.push(work);
                    const card = document.createElement('div');
                    card.className = 'work-card';
                    card.onclick = () => openOverlay(globalIdx);

                    const imgSrc = `img/gallery/${work.cover || (Array.isArray(work.img) ? work.img[0] : work.img)}`;

                    card.innerHTML = `
                        ${work.type === 'series' ? `<div class="series-badge"><i class="fa-solid fa-copy"></i> ${work.img.length}</div>` : ''}
                        <img 
                            src="${imgSrc}" 
                            alt="${work.title}"
                            onload="this.classList.add('loaded')"
                            onerror="this.closest('.work-card').remove()"
                        >
                    `;
                    grid.appendChild(card);
                });
                container.appendChild(group);
            });
        }

        // 建立一個統一修正高度的函式
        function fixOverlayHeight() {
            const overlay = document.getElementById('workOverlay');
            if (overlay && overlay.classList.contains('active')) {
                // 使用 window.innerHeight 取得排除瀏覽器工具欄後的真實像素高度
                overlay.style.height = window.innerHeight + 'px';
            }
        }

        function openOverlay(index) {
            currentIndex = index;
            isViewerActive = false;
            currentInnerIndex = 0;
            document.getElementById('clapSection').classList.remove('ready');
            
            updateOverlayUI();
            
            const overlay = document.getElementById('workOverlay');
            overlay.classList.add('active');
            
            // 開啟時立即修正一次高度
            fixOverlayHeight();
            
            document.body.style.overflow = 'hidden';
            document.body.style.backgroundColor = '#000000'; // 開啟時將底色變黑
        }

        // 監聽螢幕旋轉或視窗大小改變（例如導覽列隱藏時）
        window.addEventListener('resize', fixOverlayHeight);

        // 額外處理：針對 iOS Chrome 導覽列消失後的瞬間補償
        window.addEventListener('scroll', () => {
            if (document.getElementById('workOverlay').classList.contains('active')) {
                fixOverlayHeight();
            }
        });

        function updateOverlayUI() {
            resetAllZoom(); 

            const item = currentFilteredWorks[currentIndex];
            if (!item) return;

            const coverFile = item.cover || (Array.isArray(item.img) ? item.img[0] : item.img);
            document.getElementById('infoCoverImg').src = `img/gallery/${coverFile}`;
            
            // 標題顯示：GAS 已淨化，直接顯示純淨標題
            document.getElementById('infoTitle').innerText = item.title;
            document.getElementById('infoDesc').innerText = item.desc || "";


            // 日期顯示：確保顯示狀態為 block，並填入日期
            const dateElement = document.getElementById('infoDate');
            dateElement.style.display = 'block'; // 強制顯示日期
            dateElement.innerText = item.date;

            // --- 以下邏輯維持不變 ---
            const currentCat = item.category;
            const infoPrev = document.getElementById('infoPrev');
            const infoNext = document.getElementById('infoNext');
            if (infoPrev) infoPrev.style.visibility = (currentIndex > 0 && currentFilteredWorks[currentIndex-1].category === currentCat) ? 'visible' : 'hidden';
            if (infoNext) infoNext.style.visibility = (currentIndex < currentFilteredWorks.length - 1 && currentFilteredWorks[currentIndex+1].category === currentCat) ? 'visible' : 'hidden';

            const isSeries = item.type === 'series';
            const pageBadge = document.getElementById('infoPageCount');
            const coverBox = document.getElementById('infoCoverBox');

            // --- 偵測圖片比例 (橫式 vs 直式) ---
            // 1. 先取得圖片 DOM 元素
            const imgElement = document.getElementById('infoCoverImg');
            const infoDetail = document.getElementById('infoDetail');


            // 2. 定義偵測函數
            function checkImageRatio() {
                // 移除舊的 Class，確保狀態乾淨
                infoDetail.classList.remove('portrait-info', 'landscape-info');

                const width = imgElement.naturalWidth;
                const height = imgElement.naturalHeight;

                if (height >= width) {
                    infoDetail.classList.add('portrait-info');
                } else {
                    infoDetail.classList.add('landscape-info');
                }
            }

            // 3. 綁定偵測時機
            // 如果圖片已經載入過（快取），直接執行
            if (imgElement.complete && imgElement.naturalWidth !== 0) {
                checkImageRatio();
            } else {
                // 如果圖片還在載入，監聽 load 事件
                imgElement.onload = checkImageRatio;
            }


            if (isSeries) {
                pageBadge.innerText = `続きを読む [${item.img.length}P]`;
                pageBadge.classList.add('badge-icon'); // 加入一個標記類別
                pageBadge.classList.add('active');
                coverBox.classList.add('is-series');
            } else {
                pageBadge.classList.remove('active');
                coverBox.classList.remove('is-series');
            }

            if (isViewerActive && isSeries) {
                document.getElementById('infoLayer').style.display = 'none';
                document.getElementById('viewerLayer').classList.add('active');
                document.getElementById('overlayCloseBtn').style.display = 'none';
                document.getElementById('overlayBackBtn').style.display = 'flex';
                updateViewerImage();
            } else {
                document.getElementById('infoLayer').style.display = 'flex';
                document.getElementById('viewerLayer').classList.remove('active');
                document.getElementById('overlayCloseBtn').style.display = 'flex';
                document.getElementById('overlayBackBtn').style.display = 'none';
            }

            if (window.syncClaps) window.syncClaps(item.id);
        }

        function updateViewerImage() {

            resetAllZoom(); // 換頁時重置縮放

            const item = currentFilteredWorks[currentIndex];
            const imgs = item.img;
            document.getElementById('viewerImg').src = `img/gallery/${imgs[currentInnerIndex]}`;
            
            const viewPrev = document.getElementById('viewPrev');
            const viewNext = document.getElementById('viewNext');
            if (viewPrev) viewPrev.classList.toggle('btn-hidden', currentInnerIndex === 0);
            if (viewNext) viewNext.classList.toggle('btn-hidden', currentInnerIndex === imgs.length - 1);

            const indicator = document.getElementById('viewerIndicator');
            indicator.innerHTML = imgs.map((_, i) => `<span class="dot ${i === currentInnerIndex ? 'active' : ''}"></span>`).join('');
        }

        function changeWork(step) {
            const newIdx = currentIndex + step;
            if (newIdx >= 0 && newIdx < currentFilteredWorks.length) {
                if (currentFilteredWorks[newIdx].category === currentFilteredWorks[currentIndex].category) {
                    currentIndex = newIdx;
                    currentInnerIndex = 0;
                    document.getElementById('clapCount').innerText = "-";
                    document.getElementById('clapCountStatus').innerText = "-";
                    updateOverlayUI();
                }
            }
        }

        function changeInnerPage(step) {
            const item = currentFilteredWorks[currentIndex];
            const targetIndex = currentInnerIndex + step;
            if (targetIndex >= 0 && targetIndex < item.img.length) {
                currentInnerIndex = targetIndex;
                updateViewerImage();
            }
        }

        function enterViewer() { isViewerActive = true; currentInnerIndex = 0; updateOverlayUI(); }
        function backToInfo() { isViewerActive = false; updateOverlayUI(); }
        function closeOverlay() {
            document.getElementById('workOverlay').classList.remove('active');
            document.body.style.overflow = 'auto';
            document.body.style.backgroundColor = ''; // 關閉時還原底色
        }
        function handleOverlayClick(e) { if (e.target.id === 'workOverlay') closeOverlay(); }
        function tryEnterViewer() { if (currentFilteredWorks[currentIndex].type === 'series') enterViewer(); }

        function initTouchEvents() {
            const infoBox = document.getElementById('infoCoverBox');
            const viewerBox = document.querySelector('.viewer-img-container');

            const handleStart = (e) => {
                if (e.touches.length === 2) {
                    // 雙指開始縮放
                    isZooming = true;
                    startDist = getDistance(e.touches[0], e.touches[1]);
                } else if (e.touches.length === 1) {
                    // 單指開始
                    touchStartX = e.touches[0].clientX;
                    touchStartY = e.touches[0].clientY;
                    startTouchX = e.touches[0].clientX - posX;
                    startTouchY = e.touches[0].clientY - posY;
                    isSwiping = (scale <= 1.1); // 只有沒縮放時才啟動滑動切換
                }
            };

            let lockDirection = null; // 用於鎖定方向：'horizontal', 'vertical', 或 null

            const handleMove = (e) => {
                const targetImg = isViewerActive ? document.getElementById('viewerImg') : document.getElementById('infoCoverImg');
                if (!targetImg) return;

                // 1. 雙指縮放邏輯 (優先處理，縮放時不考慮方向鎖定)
                if (e.touches.length === 2 && isZooming) {
                    e.preventDefault();
                    const currentDist = getDistance(e.touches[0], e.touches[1]);
                    const diff = currentDist / startDist;
                    scale = Math.min(Math.max(1, lastScale * diff), 3);
                    updateTransform(targetImg);
                    return; // 雙指操作結束，跳出
                }

                // 2. 單指操作邏輯
                if (e.touches.length === 1) {
                    const currentX = e.touches[0].clientX;
                    const currentY = e.touches[0].clientY;
                    const dx = currentX - touchStartX;
                    const dy = currentY - touchStartY;

                    // --- 方向鎖定判定 (Directional Lock) ---
                    if (!lockDirection) {
                        // 移動超過 6px 進行判定，避免過於靈敏
                        if (Math.abs(dx) > 6 || Math.abs(dy) > 6) {
                            if (Math.abs(dx) > Math.abs(dy)) {
                                lockDirection = 'horizontal';
                            } else {
                                lockDirection = 'vertical';
                            }
                        }
                        // 還沒判定出方向前，先不做任何事
                        if (!lockDirection) return;
                    }

                    // --- 根據鎖定方向執行對應邏輯 ---
                    
                    if (lockDirection === 'vertical') {
                        // [垂直鎖定模式]：不執行 preventDefault，讓瀏覽器原生上下滑動網頁
                        // 此時不更新圖片 transform，確保 X 軸完全不動
                        return; 
                    }

                    if (lockDirection === 'horizontal') {
                        // [水平鎖定模式]：
                        // 阻止瀏覽器預設行為（防止在水平滑動時頁面跟著上下晃動）
                        if (e.cancelable) e.preventDefault();

                        if (scale > 1.1) {
                            // A. 縮放狀態下的拖動 (Pan)
                            posX = currentX - startTouchX;
                            posY = currentY - startTouchY;
                            updateTransform(targetImg);
                        } else if (isSwiping) {
                            // B. 1x 狀態下的水平換頁預覽
                            // 由於已經鎖定 horizontal，這裡不需要再 Math.abs 判斷
                            targetImg.style.transition = 'none';
                            targetImg.style.transform = `translateX(${dx * 0.3}px)`;
                        }
                    }
                }
            };

            const handleEnd = (e) => {
                lockDirection = null; // 手指離開時釋放方向鎖定
                const targetImg = isViewerActive ? document.getElementById('viewerImg') : document.getElementById('infoCoverImg');
                
                if (isZooming) {
                    lastScale = scale;
                    if (e.touches.length < 2) isZooming = false;
                }

                if (scale <= 1.1) {
                    // 處理作品切換
                    let dx = e.changedTouches[0].clientX - touchStartX;
                    if (targetImg) {
                        targetImg.style.transition = 'transform 0.3s ease';
                        targetImg.style.transform = 'scale(1) translate(0,0)';
                    }
                    if (isSwiping && Math.abs(dx) > 70) {
                        isViewerActive ? changeInnerPage(dx < 0 ? 1 : -1) : changeWork(dx < 0 ? 1 : -1);
                    }
                    // 重設位移數值
                    posX = 0; posY = 0; lastPosX = 0; lastPosY = 0;
                }
                isSwiping = false;
            };

            // 輔助函式
            function getDistance(t1, t2) {
                return Math.sqrt(Math.pow(t2.pageX - t1.pageX, 2) + Math.pow(t2.pageY - t1.pageY, 2));
            }

            function updateTransform(el) {
                el.style.transition = 'none';
                el.style.transform = `translate(${posX}px, ${posY}px) scale(${scale})`;
            }

            [infoBox, viewerBox].forEach(box => {
                if (box) {
                    box.addEventListener('touchstart', handleStart, { passive: false });
                    box.addEventListener('touchmove', handleMove, { passive: false });
                    box.addEventListener('touchend', handleEnd, { passive: true });
                }
            });
        }

        function resetAllZoom() {
            scale = 1;
            lastScale = 1;
            posX = 0;
            posY = 0;
            const imgs = [document.getElementById('infoCoverImg'), document.getElementById('viewerImg')];
            imgs.forEach(img => {
                if (img) {
                    img.style.transition = 'transform 0.2s ease';
                    img.style.transform = 'scale(1) translate(0,0)';
                }
            });
        }

        function tryEnterViewer() {
            // 只有在完全沒縮放，且不是在滑動中才允許進入
            if (scale <= 1.05 && !isZooming) {
                if (currentFilteredWorks[currentIndex].type === 'series') enterViewer();
            }
        }

        function resetUIInactivity() {
            const btns = [document.getElementById('overlayBackBtn'), document.getElementById('overlayCloseBtn')];
            btns.forEach(b => b && b.classList.remove('ui-hidden'));
            clearTimeout(uiInactivityTimeout);
            uiInactivityTimeout = setTimeout(() => {
                if (isViewerActive && window.innerWidth <= 900) btns.forEach(b => b && b.classList.add('ui-hidden'));
            }, 3000);
        }

        document.addEventListener('DOMContentLoaded', initGallery);
    </script>

    <script src="main.js"></script>
</body>
</html>